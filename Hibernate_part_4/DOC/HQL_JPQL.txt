****** Язык запросов HQL ******

HQL (Hibernate Query Language) – это объекто-ориентированный язык запросов,
который очень похож на SQL. Главное различие языков HQL и SQL связано с тем,
что SQL формирует запросы из наименований таблиц в базе данных и их столбцов,
а HQL работает с сущностями (классами) и их полями (аттрибутами класса).

Hibernate транслирует HQL–запросы в понятные для БД SQL–запросы, которые и
выполняют необходимые действия в БД.

*** Ключевые операторы языка HQL ***

*** FROM ***

Оператор FROM используется для загрузки (чтения) набора объектов.
Пример запроса:

*****************************************************************************************
String hql = "FROM User";
Query query = session.createQuery(hql);
List<User> users = query.list();
*****************************************************************************************
Тут User представляет собой POJO класс (User.java), который ассоциирован с таблицей в БД.
Не сложно заметить, что запрос возвращает список User.

*** WHERE ***

Оператор WHERE накладывает условие на выборку определенных записей из БД. В следующем коде
оператор WHERE используется точно также, как и в обычном SQL запросе:

*****************************************************************************************
Query query = session.createQuery("FROM User where name = 'Иван'");
List<User> users = query.list();
*****************************************************************************************

Hibernate может использовать оператор WHERE с именованными параметрами (Named Parameters),
определяя значение в режиме run-time. Для подстановки соответствующего значения в запрос
используется метод setParameter объекта Query, которому в качестве параметров необходимо
передать соответствующие значения:

*****************************************************************************************
String hql = "FROM User where name = :paramName";
Query query = session.createQuery(hql);
query.setParameter("paramName", "Alex");
List<User> users = query.list();
*****************************************************************************************

Запросы HQL не чувствительны к регистру операторов, за исключением названий Java классов и
их свойств. Т.е. 'SeLect' будет эквивалентен 'Select'. Но вот с наименованием сущностей/классов
и их полями это не проходит - !!! они должны соответствовать описаниям !!!

*** INSERT ***

В HQL поддерживается только форма INSERT INTO ... SELECT ... , которая имеет серьезные ограничения
для вставки записей. С точки зрения SQL данная форма позволяет вставить одну или несколько записей
в таблицу из запроса SELECT ... . !!! Но это характерно для SQL, а Hibernate (HQL) работает только с
сущностями !!!

Если использовать данную форму запроса для вставки записи в Hibernate, например так, см.
код вставки записи пользователя в БД:

*****************************************************************************************
String hql = "insert into User (login, name) " +
             "select 'oleg', 'Олег' from User";
int rows = session.createQuery (hql).executeUpdate();
System.out.println("rows : " + rows);
*****************************************************************************************

Мы вроде бы пытаемся сохранить сущности User со значениями login='oleg' и name='Олег'.
Однако, какова бы ни была структура таблицы и описание сущности (хочется верить, что правильной
и логичной), в процессе выполнения кода можно увидеть что-то вроде :

*****************************************************************************************
Hibernate:
    insert into USERS ( id, login, name )
        select SEQ_USER.nextval,
              'oleg' as col_0_0_,
              'Олег' as col_1_0_
            from USERS user0_
rows : 2
*****************************************************************************************

Т.е. Hibernate честно сформирует запрос insert и вставит 2-е записи. И если посмотреть содержимое
таблицы БД, скорее всего, там мы увидим новые две записи. Естественно вторая запись лишняя, но как
от нее избавиться. Если вместо наименования сущности User в первой или во второй позиции подставить
наименование таблицы Users, то Hibernate вызовет QuerySyntaxException, например так:

*****************************************************************************************
Exception in thread "main" \
        org.hibernate.hql.internal.ast.QuerySyntaxException: \
        Users is not mapped [ \
            insert into Users(login, name) \
                select 'oleg', 'Олег' from net.common.model.User]
*****************************************************************************************

Описанная выше проблема, четко дает понять, что при работе с HQL мы оперируем сущностями, а значит,
вставку записей в таблицы при использовании HQL необходимо выполнять с применением стандартных методов
*.save() или *.saveUpdate() объекта сессии, как мы проделывали в прошлых уроках
(например, см. \Hibernate_part_3\src\main\java\oldboy\lesson_18\JoinedDemo.java).

*** UPDATE ***

Ключевое слово UPDATE используется для обновления одного или нескольких полей объекта. При формировании
HQL-запроса можно использовать именованные параметры (Named Parameters). Следующий код демонстрирует
динамическое определение параметров при обновлении записи. Результат выполнения запроса — количество
обновленных (затронутых) записей:

*****************************************************************************************
String hql = "update Contact "
               + "SET firstName = :name "
               +   ", lastName  = :lastName "
               +   ", date      = :dateParam "
               +  " where id = :idParam"
Query query = session.createQuery(hql);

query.setParameter("idParam"  , 48);
query.setParameter("name"     , "Киса");
query.setParameter("lastName" , "Воробьянинов");
query.setParameter("dateParam", new Date());

int result = query.executeUpdate();
*****************************************************************************************

*** DELETE ***

Ключевое слово DELETE используется для удаления одного или нескольких объектов из таблицы.
Пример:

*****************************************************************************************
String hql = "DELETE User WHERE login = :lg";
Query query = session.createQuery(hql);
query.setParameter("lg", "oleg");
int rows = query.executeUpdate();
*****************************************************************************************

Представленный выше код будет выполнен, только если сущность User не имеет связанных объектов,
т.е. из таблицы БД будет удалена сущность. Но, если к примеру, User имеет один или несколько
связанных объектов (без требуемой настройки @Cascade(org.hibernate.annotations.CascadeType.DELETE)),
то сервер БД не сможет удалить запись из таблицы Users, поскольку в свзанные таблицы имеются
«перекрестно/ссылочные» записи. В этом случае Hibernate вызовет (выбросит):

*****************************************************************************************
org.hibernate.exception.ConstraintViolationException : could not execute statement.
*****************************************************************************************

Для удаления связанных сущностей необходимо использовать объект сессии Session. Следующий код
демонстрирует удаление пользователя User, у которого имеются связанные объекты (сущности):

*****************************************************************************************
User user = session.load(User.class, 50);
if (user != null) {
    session.delete(user);
}
*****************************************************************************************

В консоль будут выведены следующие сформированные Hibernate запросы удаления сущности User
и связанных с ней сущностей Auto :

*****************************************************************************************
Hibernate: delete from 'связанная_таблица' where 'связанная сущность_id'=?
Hibernate: delete from USERS where id=?
*****************************************************************************************

!!! Нужно помнить, что дочерние/связанные сущности удаляются в первую очередь !!!

*** Использование алиаса/псевдонима AS ***

Оператор AS можно использовать в качестве алиаcа (псевдонима) в HQL запросе, особенно, если
запрос получается длинным. Следующий код демонстрирует определение алиаса пользователя User
как 'u' (без его использования в запросе):

*****************************************************************************************
String hql = "FROM User AS u";
Query query = session.createQuery(hql);
List results = query.list();
*****************************************************************************************

Оператор AS можно не включать (опускать) в запрос, и сразу же после наименования сущности
определить ее алиас:

*****************************************************************************************
String hql = "FROM User u";
Query query = session.createQuery(hql);
List results = query.list();
*****************************************************************************************

Ниже представлены примеры кода с использованием алиаса (псевдонима).

*** GROUP BY ***

При использовании в HQL агрегатных функций необходимо выполнять группировку по определенным в
запросе полям, аналогично SQL. Следующий код демонстрирует использование агрегатной функции SUM
с группировкой по полю firstName сущности Employee:

*****************************************************************************************
             /* Уже применяем псевдоним, который будет задан строкой ниже */
String hql = "SELECT SUM (e.salary), e.firtName " +
             /* Задали псевдоним */
             "FROM Employee e " +
             "GROUP BY e.firstName";
Query query = session.createQuery(hql);
List results = query.list();
*****************************************************************************************

*** Агрегатные функции HQL ***

В таблице представлены агрегатные функции, поддерживаемые HQL :
---------------------------------------------------------------
Функция	                   | Описание
---------------------------------------------------------------
avg (property name)	       | получение среднего значения
count (property name or *) | получение количества записей
max (property name)	       | получение максимального значения
min (property name)	       | получение минимального значения
sum (property name)	       | вычисление суммарного значения
---------------------------------------------------------------

*** DISTINCT ***

Использование оператора DISTINCT позволяет выделить уникальные значения.
Следующий запрос вернет количество уникальных имен сотрудников:

*****************************************************************************************
String hql = "SELECT COUNT (distinct e.firstName) "
              + "FROM Employee e";
Query query = session.createQuery(hql);
List results = query.list();
*****************************************************************************************

*** ORDER BY ***

Сортировка результатов запроса в HQL выполняется с использованием ORDER BY аналогично SQL.
Сортировать значения можно:
- как по возрастанию (ASC ascending);
- так и по убыванию (DESC descending).

Следующий код демонстрирует чтение сотрудников с сортировкой по убыванию:

*****************************************************************************************
            /* Применяем (задаем) псевдоним */
String hql = "FROM Employee e " +
             "WHERE e.id > 10 ORDER BY e.salary DESC";
Query query = session.createQuery(hql);
List results = query.list();
*****************************************************************************************

Если необходимо выполнить сортировку более чем по одному из полей, то можно после оператора
ORDER BY указать список полей с порядком сортировки, разделенных запятой:

*****************************************************************************************
             /* Задаем alias (псевдоним) */
String hql = "FROM Employee e " +
             "WHERE e.id > 10 " +
             "ORDER BY e.firstName DESC, e.salary DESC";
Query query = session.createQuery(hql);
List results = query.list();
*****************************************************************************************

*** Разбиение на страницы (ограничение вывода информации) ***

Объект Query включает два метода, позволяющие организовать разбиение данных по-страницам:
- setFirstResult (int start) — параметр start определяет первую извлекаемую запись в
                               запросе (отсчет от 0);
- setMaxResults (int max) — параметр max определяет количество извлекаемых записей в
                            результирующем запросе.

Используя вышеописанные методы можно организовать постраничное представление набора данных.
Следующий пример выбирает из БД 8 сотрудников, начиная с 5-ой записи:

*****************************************************************************************
String hql = "FROM Employee";
Query query = session.createQuery(hql);
query.setFirstResult(5);
query.setMaxResults (8);
List results = query.list();
*****************************************************************************************