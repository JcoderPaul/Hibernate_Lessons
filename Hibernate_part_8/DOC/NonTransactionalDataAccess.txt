****** Нетранзакционный доступ к данным и режим автоматической фиксации (auto-commit mode) ******

(Это сокращенный отрывок из главы 10 книги:
                    Java Persistence with Hibernate Second Edition of Hibernate in Action
                    by Christian Bauer and Gavin King)

Многие СУБД по умолчанию включают так называемый режим автоматической фиксации (auto-commit mode) при каждом
новом подключении к базе данных. Режим автоматической фиксации полезен для специального выполнения SQL.

Представьте, что вы подключаетесь к своей базе данных с помощью консоли SQL и выполняете несколько запросов и,
возможно, даже обновляете и удаляете строки. Этот интерактивный доступ к данным является специальным; в большинстве
случаев у вас нет плана или последовательности утверждений (запросов), которые вы считаете единицей работы.
Режим автофиксации (auto-commit) по умолчанию для соединения с базой данных идеально подходит для такого доступа
к данным — в конце концов, вы не хотите вводить «начать транзакцию» и «завершить транзакцию» для каждого оператора
SQL, который вы пишете и выполняете.

В режиме автоматической фиксации (короткая) транзакция базы данных начинается и завершается для каждого оператора
SQL, который вы отправляете в базу данных. Вы эффективно работаете без транзакций, потому что для вашего сеанса с
консолью SQL нет гарантий атомарности или изоляции. (Единственная гарантия состоит в том, что один оператор SQL
является атомарным.)

Приложение по определению всегда выполняет запланированную последовательность операторов. Поэтому кажется разумным,
что вы всегда создаете границы транзакций, чтобы сгруппировать свои операторы в единицы, которые являются атомарными.
Следовательно, режим автоматической фиксации неуместен в приложении (однако тоже может быть там реализован).

*** Развенчание мифов об автоматической фиксации (auto-commit) ***

Многим разработчикам по-прежнему нравится работать в режиме автоматической фиксации, часто по неясным и не совсем
определенным причинам. Давайте сначала разоблачим некоторые из этих причин, прежде чем мы покажем вам, как получить
доступ к данным без транзакций, если вы хотите (или должны):

- Многие разработчики приложений думают, что они могут общаться с базой данных вне транзакции. Это, очевидно,
  невозможно; оператор SQL не может быть отправлен в базу данных вне транзакции базы данных. Термин 'нетранзакционный
  доступ к данным' означает 'отсутствие явных границ транзакций' (но они все равно есть), системных транзакций и
  поведение при доступе к данным в режиме автоматической фиксации. Это не означает, что физические транзакции базы
  данных не задействованы (еще раз, транзакции есть даже если их и не видно, как суслика в старой байке).

- Если ваша цель — повысить производительность вашего приложения с помощью режима автоматической фиксации, вам
  следует еще раз подумать о последствиях множества небольших транзакций. Значительные накладные расходы связаны с
  запуском и завершением транзакции базы данных для каждого оператора SQL, и это может снизить производительность
  вашего приложения (т.е стрельба картечью эффективнее, чем очередью).

- Если ваша цель — улучшить масштабируемость вашего приложения с помощью режима автоматической фиксации, подумайте
  еще раз: длительная транзакция базы данных вместо множества небольших транзакций для каждого оператора SQL может
  удерживать блокировки базы данных в течение более длительного времени и, вероятно менее предпочтительна. Однако
  благодаря контексту сохраняемости (persistence context) Hibernate и отложенной записи DML все блокировки записи
  в базе данных удерживаются в течение короткого времени.

  В зависимости от включенного уровня изоляции стоимость блокировок чтения, скорее всего, будет незначительной.
  Или вы можете использовать СУБД с многоверсионным параллелизмом, не требующим блокировки чтения (Oracle, PostgreSQL,
  Informix, Firebird), поскольку по умолчанию читатели никогда не блокируются.

- Поскольку вы работаете без транзакций, вы не только отказываетесь от любой транзакционной атомарности группы
  операторов SQL, но также получаете более слабые гарантии изоляции, если данные изменяются одновременно.
  Повторяющиеся операции чтения, основанные на блокировках чтения, невозможны в режиме автоматической фиксации.
  (Здесь, естественно, помогает кеш контекста персистентности - persistence context)

Когда вы используете нетранзакционный доступ к данным в своем приложении, необходимо учитывать еще много вопросов.
Мы уже отмечали, что введение нового типа транзакций, а именно транзакций только для чтения, может значительно
усложнить любую будущую модификацию вашего приложения. То же самое верно, если вы вводите нетранзакционные операции.

Тогда у вас будет три различных вида доступа к данным в вашем приложении:
- в обычных транзакциях,
- в транзакциях только для чтения,
- а теперь еще и без транзакций, без каких-либо гарантий.

Представьте, что вам нужно ввести операцию записи данных в единицу работы, которая должна была только считывать
данные. Представьте, что вам нужно реорганизовать операции, которые раньше были нетранзакционными, чтобы сделать
их транзакционными.

Мы РЕКОМЕНДУЕМ НЕ ИСПОЛЬЗОВАТЬ РЕЖИМ АВТО-ФИКСАЦИИ (AUTO-COMMIT) в приложении и применять транзакции только для
чтения только тогда, когда есть очевидное преимущество в производительности или когда будущие изменения кода
крайне маловероятны. Всегда предпочитайте обычные ACID-транзакции для группировки операций доступа к данным,
независимо от того, читаете вы данные или записываете.

При этом Hibernate и Java Persistence обеспечивают нетранзакционный доступ к данным. На самом деле спецификация
EJB 3.0 заставляет вас обращаться к данным без транзакций, если вы хотите реализовать атомарные длительные диалоги.

Теперь углубимся в последствия режима автоматической фиксации в простом приложении Hibernate.
(Обратите внимание, что, несмотря на наши отрицательные замечания, есть несколько хороших вариантов использования
режима автоматической фиксации. По нашему опыту, автоматическая фиксация часто включается по неправильным причинам,
и мы хотим пояснить этот момент.)

*** Работа без транзакций с Hibernate ***

Посмотрите на следующий код, который обращается к базе данных без границ транзакций:

*******************************************************************************************************************
Session session = sessionFactory.openSession();
session.get(Item.class, 123l);
session.close();
*******************************************************************************************************************

По умолчанию в среде Java SE с конфигурацией JDBC вот что произойдет, если вы выполните этот фрагмент кода:
1. Открывается новая сессия. На данный момент он не получает соединение с базой данных.

2. Вызов get() запускает SQL SELECT. Теперь сеанс получает соединение JDBC из пула соединений.
   Спящий режим по умолчанию немедленно отключает режим автоматической фиксации для этого
   соединения с помощью setAutoCommit(false). Это фактически запускает транзакцию JDBC!

3. SELECT выполняется внутри этой JDBC-транзакции. Сессия закрывается, а соединение возвращается
   в пул и освобождается Hibernate — Hibernate вызывает close() для соединения JDBC.

Что происходит с незафиксированной транзакцией?

Ответ на этот вопрос: «Это зависит!» Спецификация JDBC ничего не говорит об ожидающих транзакциях, когда для
соединения вызывается функция close(). Что произойдет, зависит от того, как поставщики реализуют спецификацию.
Например, в драйверах Oracle JDBC вызов close() фиксирует транзакцию! Большинство других поставщиков JDBC
выбирают разумный путь и откатывают любую ожидающую транзакцию, когда объект JDBC Connection закрывается и
ресурс возвращается в пул.

Очевидно, что это не будет проблемой для выполненного вами SELECT, но посмотрите на этот вариант:

*******************************************************************************************************************
Session session = getSessionFactory().openSession();
Long generatedId = session.save(item);
session.close();
*******************************************************************************************************************

Этот код приводит к инструкции INSERT, выполняемой внутри транзакции, которая никогда не фиксируется и не
откатывается. В Oracle этот фрагмент кода постоянно вставляет данные; в других базах данных может и не быть.
(Эта ситуация немного сложнее: INSERT выполняется только в том случае, если этого требует генератор идентификаторов.
Например, значение идентификатора может быть получено из последовательности без INSERT. Затем постоянный объект
ставится в очередь до момента вставки во время сброса, что никогда не происходит в этом коде. Стратегия идентификации
требует немедленного INSERT для создания значения.)

Мы еще даже не коснулись режима автофиксации, а только выделили проблему, которая может возникнуть, если вы
попытаетесь работать без установки явных границ транзакций. Давайте предположим, что вы по-прежнему считаете
работу без разграничения транзакций хорошей идеей и хотите использовать обычное поведение автофиксации.

Во-первых, вы должны сообщить Hibernate, чтобы разрешить автоподтверждение JDBC-соединений в Hibernate configuration:

*******************************************************************************************************************
<property name="connection.autocommit">true</property>
*******************************************************************************************************************

С этим параметром Hibernate больше не отключает автоматическую фиксацию при получении соединения JDBC из пула
соединений — она включает автоматическую фиксацию, если соединение еще не находится в этом режиме. Предыдущие
примеры кода теперь работают предсказуемо, а драйвер JDBC оборачивает короткую транзакцию вокруг каждого оператора
SQL, отправляемого в базу данных, — с последствиями, перечисленными ранее.

В каких сценариях вы бы включили режим автоматической фиксации в Hibernate, чтобы можно было использовать сеанс
без запуска и завершения транзакции вручную? Системы, которые выигрывают от режима автоматической фиксации — это
системы, требующие (ленивой) загрузки данных по запросу в конкретном сеансе и контексте сохраняемости, но в которых
трудно обернуть границы транзакций вокруг всего кода, который может вызвать извлечение данных по запросу.

С другой стороны, настольные приложения, которые получают доступ к уровню базы данных через Hibernate, часто требуют
загрузки по требованию без явных границ транзакций. Например, если дважды щелкнуть узел в древовидном представлении
Java Swing, все дочерние элементы этого узла должны быть загружены из базы данных. Вам придется обернуть транзакцию
вокруг этого события вручную; режим автоматической фиксации является более удобным решением. (! Обратите внимание,
что мы не предлагаем открывать и закрывать сеансы по требованию !)

***********************************************************************************************************************
См. полную версию: https://developer.jboss.org/docs/DOC-13953
***********************************************************************************************************************
