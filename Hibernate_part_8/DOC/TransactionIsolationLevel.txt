****** Уровни изолированности транзакций ******

Транзакция (очередное определение) - это N (N≥1) запросов к БД, которые выполнятся успешно все вместе
или не выполнятся вовсе. Изолированность же транзакции показывает то, насколько сильно влияют друг на
друга параллельно выполняющиеся транзакции.

Выбирая уровень транзакции, мы пытаемся прийти к консенсусу в выборе между высокой согласованностью
данных между транзакциями и скоростью выполнения этих самых транзакций. Стоит отметить, что самую
высокую скорость выполнения и самую низкую согласованность имеет уровень read uncommitted. Самую
низкую скорость выполнения и самую высокую согласованность — serializable.

*** Read uncommitted ***

Уровень, имеющий самую плохую согласованность данных, но самую высокую скорость выполнения транзакций.
Название уровня говорит само за себя — каждая транзакция видит незафиксированные изменения другой
транзакции (феномен грязного чтения).

На данном уровне нельзя использовать данные, на основе которых делаются важные для приложения выводы и
критические решения т.к выводы эти могут быть далеки от реальности.

Данный уровень можно использовать, например, для примерных расчетов чего-либо. Результат COUNT(*) или
MAX(*) можно использовать в каких-нибудь нестрогих отчетах. Другой пример это режим отладки. Когда во
время транзакции, вы хотите видеть, что происходит с базой.

*** Read committed ***

Для этого уровня параллельно исполняющиеся транзакции видят только зафиксированные изменения из других
транзакций. Таким образом, данный уровень обеспечивает защиту от грязного чтения.

*** Repeatable read ***

Уровень, позволяющий предотвратить феномен неповторяющегося чтения. Т.е. мы не видим в исполняющейся
транзакции измененные и удаленные записи другой транзакцией. Но все еще видим вставленные записи из
другой транзакции. Чтение фантомов никуда не уходит.

Однако все зависит от особенностей БД в MySQL отсутствует эффект чтения фантомов для уровня repeatable
read и в PostgreSQL от него тоже избавились для этого уровня. Хотя в классическом представлении этого
уровня, мы должны наблюдать этот эффект.

Небольшой абстрактный пример — сервис генерации подарочных сертификатов (кодов) и их использования.
Например, злоумышленник сгенерировал себе код сертификата и пытается его активировать, пытаясь послать
несколько запросов подряд на активацию купона. В таком случае у нас запустится несколько параллельно
исполняемых транзакций, работающих с одним и тем же купоном. И в некоторых ситуациях может возникнуть
двойная или даже тройная активация купона (пользователь получит 2x/3x бонусов). При repeatable read в
данном случае возникнет lock и активация пройдет единожды, а в предыдущих 2 уровнях возможна многократная
активация. Подобную проблему можно также решить с помощью запроса SELECT FOR UPDATE, который также
заблокирует обновляемую запись (купон).

*** Serializable ***

Уровень, при котором транзакции ведут себя как будто ничего более не существует, никакого влияния друг
на друга нет. В классическом представлении этот уровень избавляет от эффекта чтения фантомов.

Уровни изолированности транзакций:
--------------------------------------------------------------------------------------
Уровни изолированности | Phantom Read | NonRepeatable Read | Dirty Read | LostUpdate
--------------------------------------------------------------------------------------
Serializable           |      +       |         +          |     +      |      +
--------------------------------------------------------------------------------------
Repeatable read        |      -       |         +          |     +      |      +
--------------------------------------------------------------------------------------
Read committed         |      -       |         -          |     +      |      +
--------------------------------------------------------------------------------------
Read uncommitted       |      -       |         -          |     -      |      +
--------------------------------------------------------------------------------------

См. схему: PhantomRead.jpg, NonRepeatableRead.jpg, DirtyRead.jpg, LostUpdate.jpg

Особенности и рекомендации:

В большинстве приложений уровень изолированности редко меняется и используется значение по умолчанию
(например, в MySQL это repeatable read, в PostgreSQL — read committed), отсюда совет - управляйте
уровнями изолированности транзакций в коде приложения, для каждой транзакции в отдельности.

Всегда необходимо искать лучший баланс между высокой согласованностью данных или скоростью выполнения
транзакций может помочь решить некоторую прикладную задачу.