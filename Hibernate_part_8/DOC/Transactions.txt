****** Transactions в Hibernate ******

Библиотека (пакет): org.hibernate
Интерфейс: Interface Transaction
Все известные классы реализации: CMTTransaction , JDBCTransaction , JTATransaction

Позволяет приложению определять единицы работы, сохраняя при этом абстракцию от базовой реализации
транзакции (например, JTA, JDBC).

Транзакция связана с сеансом и обычно создается вызовом Session.beginTransaction(). Один сеанс может
охватывать несколько транзакций, поскольку понятие сеанса (диалог между приложением и хранилищем данных)
имеет более грубую степень детализации, чем понятие транзакции. Однако предполагается, что в любое
время может быть не более одной незафиксированной транзакции, связанной с конкретным сеансом.

Реализации интерфейса не потокобезопасны.

Транзакция (Transaction) – это группа действий, которые должны быть выполнены только все вместе.
Если какое-либо действие не выполнилось или выполнилось с ошибкой, то все остальные действия
должны быть отменены (см. DOC/TransactionLifeCycle.jpg).

Hibernate умеет работать с двумя видами транзакций:
- JDBC – это фактически транзакция базы данных. Она привязана к работе с базой данных, к
         JDBC-соединению. И следит за тем, чтобы действия при работе с базой данных выполнялись
         как надо: или все или ничего;
- JTA – это транзакция уровня приложения. Она не привязана ни к какой базе данных. Ее задача
        следить, чтобы некоторые действия выполнялись: или все, или ничего;

        Например, мы можем записывать данные в несколько разных баз данных в рамках одной
        JTA-транзакции. Тогда если произойдет ошибка, то JTA-транзакция должна будет откатить
        изменения во всех базах данных. Даже те, которые были выполнены успешно с точки зрения
        конкретной базы данных.

*** Hibernate Transactions Interface ***

В библиотеке Hibernate транзакция представлена интерфейсом Transaction, который может иметь
различные реализации. Например, при работе со Spring, Spring предоставляет свой собственный
механизм JTA-транзакций.

Методы этого интерфейса такие:
------------------------------------------------------------------------------------------------------
Метод                     | Описание
------------------------------------------------------------------------------------------------------
begin()                   | Стартует новую транзакцию
commit()	              | Заканчивает транзакцию, пушит/комитит все изменения
rollback()	              | Откатывает текущую транзакцию
setTimeout(int seconds)	  | Устанавливает максимальное время выполнения транзакции
isActive()	              | Проверяет активная транзакция или нет
wasRolledBack()	          | Проверяет нормально ли откатилась транзакция
wasCommitted()	          | Проверяет нормально ли транзакция закомитилась
registerSynchronization() | Регистрирует callback для контроля транзакции
------------------------------------------------------------------------------------------------------

******************************************************************************************************
См. более подробно: https://docs.jboss.org/hibernate/orm/3.2/api/org/hibernate/Transaction.html
******************************************************************************************************

!!! Важно !!!
Создание объекта транзакции и запуск транзакции – это разные вещи. Тут можно провести аналогию с классом
Thread. Когда мы создаем объект Thread(), то новый поток, JVM не запускает сразу. Чтобы его запустить,
нужно вызвать метод start() у объекта Thread. То же самое и с транзакцией – ей нужно вызвать стартовый
метод *.beginTransaction().

Пример того, как обычно работают с транзакциями в Hibernate (см. TransactionsDemo.java):

******************************************************************************************************
    Session session = sessionFactory.openSession();
    Transaction transaction = session.getTransaction();
    try {
        transaction.begin();
        Long count = session.createQuery("select count(*) from Employee", Long.class).uniqueResult();
        transaction.commit();
    }
    catch (Exception e) {
        if (transaction.getStatus() == ACTIVE || transaction.getStatus() == MARKED_ROLLBACK) {
        transaction.rollback();
        }
    }
    finally {
        session.close();
        sessionFactory.close();
    }
******************************************************************************************************
Мы тут видим три вещи:
- Во-первых, вся работа с базой оборачивается в транзакцию с помощью вызова методов *.begin() и *.commit()
  Все действия между вызовами этих двух методов должны быть выполнены: или все вместе, или ни одно.
- Во-вторых, если произошла любая ошибка мы пробуем откатить транзакцию – вызвать метод *.rollback().
  Это значит, что TransactionManger должен сначала записывать все действия, которые были между *.begin()
  и *.commit(), а затем вернуть все как было, если мы вызвали *.rollback().
- В-третьих, не факт, что при вызове метода *.rollback() не произойдет ошибки. Процесс отката транзакции
  тоже нужно контролировать.

*** Transaction Manager ***

С точки зрения менеджмента транзакций, Hibernate – это просто облегченная оболочка объектов для JDBC.
Сам Hibernate не имеет функций обработки транзакций. Hibernate Transaction на самом деле является
оболочкой для базовой транзакции JDBC (или оболочки транзакций JTA). JDBCTransaction используется по
умолчанию. Пример из файла настроек Hibernate:

******************************************************************************************************
hibernate.transaction.factory_class  org.hibernate.transaction.JTATransactionFactory
hibernate.transaction.factory_class  org.hibernate.transaction.JDBCTransactionFactory
******************************************************************************************************

Давай еще раз посмотрим на наш код с использованием транзакций:

******************************************************************************************************
    Session session = sessionFactory.openSession();
    Transaction transaction = session.getTransaction();
        transaction.begin();
        // some code for operation with DataBase
        session.flush();
        transaction.commit();
    session.close();
******************************************************************************************************

А теперь давай посмотрим на код класса JDBCTransaction:

******************************************************************************************************
public class JDBCTransaction implements Transaction {

    public void begin() throws HibernateException {
    	...
    	if (toggleAutoCommit) jdbcContext.connection().setAutoCommit(false);
    	...
    }
}
******************************************************************************************************

Это метод для запуска транзакции. Затем посмотреть на метод отправки:

******************************************************************************************************
public void commit() throws HibernateException {
    ...
    jdbcContext.connection().commit();
    ...
    jdbcContext.connection().setAutoCommit( true );
    ...
}
******************************************************************************************************

Теперь давай подставим этот код в код примера с Hibernate:

------------------------------------------------------------------------------------------------------
Hibernate	                                        |  Простой JDBC-код
------------------------------------------------------------------------------------------------------
Session session = sessionFactory.openSession();     |  Connection conn = jdbcContext.connection();
Transaction transaction = session.getTransaction(); |  conn.setAutoCommit(false);
transaction.beginTransaction();                     |
    // some code for operation with DataBase        |  // some code for operation with DataBase
session.flush();                                    |  conn.commit ()
transaction.getTransaction().commit();              |  conn.setAutoCommit(true);
session.close();                                    |  conn.close();
------------------------------------------------------------------------------------------------------








