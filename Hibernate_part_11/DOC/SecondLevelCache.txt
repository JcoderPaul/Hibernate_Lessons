****** Second-Level Cache - Кэш второго уровня в Hibernate ******

Как и в большинстве других полнофункциональных фреймворков ORM, в Hibernate используется концепция
кеша первого уровня. Это кеш на уровне сеанса, который гарантирует, что каждый экземпляр сущности
загружается только один раз в постоянном контексте (persistence context) см. DOC/FirstLevelCache.jpg.

После закрытия сеанса (Session) кэш первого уровня также завершается. На самом деле это необходимо,
поскольку позволяет параллельным сеансам работать с экземплярами сущностей изолированно друг от друга.

И наоборот, кэш второго уровня имеет область действия SessionFactory (см. DOC/SecondLevelCache.jpg),
что означает, что он используется всеми сеансами, созданными с помощью одной и той же фабрики сессии.
Когда экземпляр объекта ищется по его идентификатору (либо с помощью логики приложения, либо внутри
Hibernate, например, когда он загружает ассоциации с этим объектом из других объектов), и для этого
объекта включено кэширование второго уровня, происходит следующее:
- Если экземпляр уже присутствует в кеше первого уровня, он возвращается оттуда.
- Если экземпляр не найден в кеше первого уровня, а соответствующее состояние экземпляра закэшировано в
  кеше второго уровня, то данные извлекаются оттуда, а экземпляр собирается и возвращается
  (десериализуется).

В противном случае необходимые данные загружаются из базы данных, а экземпляр собирается и возвращается.
После того как экземпляр сохранен в контексте устойчивости (persistent context - кэш первого уровня), он
возвращается оттуда во всех последующих вызовах в рамках того же сеанса до тех пор, пока сеанс (session)
не будет закрыт или экземпляр не будет вручную исключен из контекста сохраняемости.

Состояние загруженного экземпляра также сохраняется в кэше L2, если его там еще нет.

****** Region Factory ******

Кэширование второго уровня Hibernate спроектировано таким образом, чтобы не знать о фактическом
используемом поставщике кэша. Hibernate нужно предоставить только с реализацией интерфейса
org.hibernate.cache.spi.RegionFactory, который инкапсулирует все детали, относящиеся к фактическим
поставщикам кэша.

По сути, он действует как мост между Hibernate и провайдерами кеша.

В нашем случае мы будем использовать Ehcache, зрелый и широко используемый кеш, в качестве поставщика
кеша. Вместо этого мы могли бы выбрать любого другого поставщика, если для него существует реализация
RegionFactory.

Мы можем добавить реализацию фабрики региона (RegionFactory) Ehcache в настройки проекта
в Maven-е:

*****************************************************************************************************
    <dependency>
        <groupId>org.hibernate</groupId>
        <artifactId>hibernate-ehcache</artifactId>
        <version>5.2.2.Final</version>
    </dependency>
*****************************************************************************************************

или Gradle-е:

*****************************************************************************************************
    implementation 'org.hibernate:hibernate-jcache:5.6.15.Final'
    implementation 'org.ehcache:ehcache:3.9.7'
*****************************************************************************************************

Мы можем посмотреть здесь последнюю версию hibernate-ehcache в репозитарии MAVEN. Однако нам нужно
убедиться, что версия hibernate-ehcache равна версии Hibernate, которую мы используем в нашем проекте
(например, если мы используем hibernate-ehcache 5.6.15.Final, как в этом примере, тогда версия
Hibernate также должно быть 5.6.15.Final).

Артефакт hibernate - ehcache зависит от самой реализации Ehcache, которая также транзитивно включена
в classpath.

*** Включение кэширования второго уровня ***

С помощью следующих двух свойств мы сообщим Hibernate, что кэширование L2 включено, и дадим ему имя
RegionFactory класса в файле hibernate.cfg.xml это будет выглядеть так:

*****************************************************************************************************
 <property name="hibernate.cache.use_second_level_cache">true</property>
    <property name="hibernate.cache.region.factory_class">
                                  org.hibernate.cache.jcache.internal.JCacheRegionFactory</property>
*****************************************************************************************************

Чтобы отключить кэширование второго уровня (скажем, в целях отладки), мы просто устанавливаем для
свойства hibernate.cache.use_second_level_cache значение в false.

*** Делаем объект кэшируемым ***

Чтобы сделать сущность подходящей для кэширования второго уровня, мы снабдим ее аннотацией @Cache из
org.hibernate.annotations, характерной для Hibernate, и укажем стратегию параллелизма кэширования
(cache concurrency strategy).

Некоторые разработчики считают хорошим соглашением добавить стандартную аннотацию @Cacheable из
javax.persistence (хотя это и не требуется для Hibernate), поэтому реализация класса сущностей может
выглядеть так:

*****************************************************************************************************
@Entity
@Cacheable
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Foo {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "ID")
    private long id;

    @Column(name = "NAME")
    private String name;

    // getters and setters
}
*****************************************************************************************************

Для каждого класса сущностей Hibernate будет использовать отдельную область кеша для хранения состояния
экземпляров этого класса. Имя региона (region name) — это полное имя класса.

*** Стратегия параллельного кэширования - Cache concurrency strategy ***

В зависимости от вариантов использования мы можем выбрать одну из следующих стратегий параллелизма кеша:
- READ_ONLY: используется только для сущностей, которые никогда не изменяются (исключение создается при
  попытке обновить такую сущность). Это очень просто и производительно. Он подходит для статических
  эталонных данных, которые не изменяются.

- NONSTRICT_READ_WRITE: кэш обновляется после того, как транзакция, которая изменила затронутые данные,
  была зафиксирована. Таким образом, строгая согласованность не гарантируется, и существует небольшое
  временное окно, в течение которого устаревшие данные могут быть получены из кэша. Этот тип стратегии
  подходит для случаев использования, которые могут допустить конечную согласованность.

- READ_WRITE: эта стратегия гарантирует строгую согласованность, которая достигается за счет использования
  «мягких» блокировок. При обновлении кэшированного объекта в кэше также сохраняется программная блокировка
  для этого объекта, которая снимается после фиксации транзакции. Все параллельные транзакции, которые
  обращаются к мягко заблокированным записям, будут извлекать соответствующие данные непосредственно из базы
  данных.

- TRANSACTIONAL: изменения кэша выполняются в распределенных транзакциях XA. Изменение в кэшированном объекте
  либо фиксируется, либо откатывается как в базе данных, так и в кэше в одной и той же транзакции XA.

*** Управление кешем ***

Если политики истечения срока действия и вытеснения не определены, кэш может расти бесконечно и в конечном
итоге использовать всю доступную память. В большинстве случаев Hibernate оставляет такие обязанности по
управлению кешем поставщикам кеша, поскольку они действительно специфичны для каждой реализации кеша.

Например, мы могли бы определить следующую конфигурацию Ehcache, чтобы ограничить максимальное количество
кэшированных экземпляров Foo до 1000:

*****************************************************************************************************
<ehcache>
    <cache name="com.baeldung.persistence.model.Foo" maxElementsInMemory="1000" />
</ehcache>
*****************************************************************************************************

*** Кэширование коллекций ***

Коллекции по умолчанию не кэшируются, и нам нужно явно пометить их как кэшируемые:

*****************************************************************************************************
@Entity
@Cacheable
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Foo {

    ...

    @Cacheable
    @org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
    @OneToMany
    private Collection<Bar> bars;

    // getters and setters
}
*****************************************************************************************************

*** Внутреннее представление кэшированного состояния ***

Сущности не хранятся в кеше второго уровня как экземпляры Java, а скорее в их дизассемблированном
(гидратированном) сереализованном состоянии:

- Идентификатор ID (первичный ключ) не сохраняется (он хранится как часть ключа кеша);
- Переходные свойства не сохраняются;
- Коллекции не сохраняются (подробнее см. ниже);
- Значения свойств, не связанных с ассоциацией, сохраняются в исходной форме;
- Для ассоциаций ToOne хранится только идентификатор (внешний ключ).

Здесь показан общий дизайн кэша второго уровня Hibernate, где модель кэша отражает лежащую в основе
реляционную модель, которая занимает мало места и позволяет легко синхронизировать их.

*** Внутреннее представление кэшированных коллекций ***

Мы уже упоминали, что мы сами должны явно указать (аннотировать), что коллекция (ассоциация OneToMany
или ManyToMany) кэшируется, иначе она не будет кэшироваться.

Hibernate фактически хранит коллекции в отдельных областях кеша, по одной для каждой коллекции. Имя
региона представляет собой полное имя класса плюс имя свойства коллекции
(например, com.baeldung.hibernate.cache.model.Foo.bars ). Это дает нам возможность определять отдельные
параметры кеша для коллекций, например политику удаления/истечения срока действия.

Также важно отметить, что для каждой записи коллекции кэшируются только идентификаторы сущностей,
содержащихся в коллекции. Это означает, что в большинстве случаев хорошей идеей является также
кэширование содержащихся объектов.

*** Инвалидация кеша для запросов в стиле HQL DML и нативных запросов ***

Когда дело доходит до HQL в стиле DML (insert, update и delete HQL-операторов), Hibernate может определить,
на какие объекты влияют такие операции:

*****************************************************************************************************
entityManager.createQuery("update Foo set … where …").executeUpdate();
*****************************************************************************************************

В этом случае все экземпляры Foo удаляются из кеша L2, в то время как остальное кэшированное содержимое
остается неизменным.

Однако, когда дело доходит до нативных операторов SQL DML, Hibernate не может угадать, что именно обновляется,
поэтому делает недействительным весь кеш второго уровня:

*****************************************************************************************************
session.createNativeQuery("update FOO set … where …").executeUpdate();
*****************************************************************************************************

Это, наверное, не то, что мы хотим. Решение состоит в том, чтобы сообщить Hibernate, на какие объекты влияют
собственные операторы DML, чтобы он мог исключать только записи, связанные с объектами Foo :

*****************************************************************************************************
Query nativeQuery = entityManager.createNativeQuery("update FOO set ... where ...");
nativeQuery.unwrap(org.hibernate.SQLQuery.class).addSynchronizedEntityClass(Foo.class);
nativeQuery.executeUpdate();
*****************************************************************************************************

Мы должны вернуться к собственному SQLQuery API Hibernate, так как эта функция еще не определена в JPA.

Обратите внимание, что вышеприведенное относится только к операторам DML (insert ,update ,delete и
собственным вызовам функций/процедур). Собственные запросы на выборку не делают кеш недействительным.

*** Кэш запросов ***

Мы также можем кэшировать результаты запросов HQL. Это полезно, если мы часто выполняем запрос к сущностям,
которые редко меняются.

Чтобы включить кеш запросов, мы установим для свойства 'hibernate.cache.use_query_cache' значение в 'true':

*****************************************************************************************************
hibernate.cache.use_query_cache=true
*****************************************************************************************************

Для каждого запроса мы должны явно указать, что запрос кэшируется
(через подсказку запроса org.hibernate.cacheable):

*****************************************************************************************************
entityManager.createQuery("select f from Foo f")
  .setHint("org.hibernate.cacheable", true)
  .getResultList();
*****************************************************************************************************

*** Рекомендации по кэшированию запросов ***

Вот некоторые рекомендации и лучшие практики, связанные с кэшированием запросов:

- Как и в случае с коллекциями, кэшируются только идентификаторы сущностей, возвращенные в результате
  кэшируемого запроса. Поэтому мы настоятельно рекомендуем включать кеш второго уровня для таких
  сущностей.

- Для каждой комбинации значений параметров запроса (переменных привязки) для каждого запроса существует
  одна запись в кэше, поэтому запросы, для которых мы ожидаем множество различных комбинаций значений
  параметров, не являются хорошими кандидатами для кэширования.

- Запросы, включающие классы сущностей, для которых в базе данных происходят частые изменения, также не
  являются хорошими кандидатами для кэширования, поскольку они будут признаны недействительными всякий
  раз, когда происходит изменение, связанное с любым классом сущностей, участвующим в запросе, независимо
  от того, кэшируются ли измененные экземпляры как часть результата запроса или нет.

- По умолчанию все результаты кэширования запросов хранятся в регионе (region)
  org.hibernate.cache.internal.StandardQueryCache. Как и в случае кэширования сущностей/коллекций, мы можем
  настроить параметры кэша для этого региона (region), чтобы определить политики удаления и истечения срока
  действия в соответствии с нашими потребностями. Для каждого запроса мы также можем указать собственное имя
  региона, чтобы предоставить разные настройки для разных запросов.

- Для всех таблиц, которые запрашиваются как часть кешируемых запросов, Hibernate хранит метки времени последнего
  обновления в отдельной области с именем org.hibernate.cache.spi.UpdateTimestampsCache. Знание этой области очень
  важно, если мы используем кэширование запросов, потому что Hibernate использует его для проверки того, что
  результаты кэшированных запросов не устарели. Записи в этом кэше не должны быть вытеснены или просрочены,
  пока есть кэшированные результаты запросов для соответствующих таблиц в областях результатов запросов. Лучше
  всего отключить автоматическое вытеснение и истечение срока действия для этой области кэша, так как она в любом
  случае не потребляет много памяти.

*****************************************************************************************************
См. полный вариант статьи: https://www.baeldung.com/hibernate-second-level-cache

Хабр о кэше второго уровня: https://habr.com/ru/articles/135176/

Ggeeksforgeeks о кэше второго уровня:
https://www.geeksforgeeks.org/hibernate-enable-and-implement-first-and-second-level-cache/
*****************************************************************************************************